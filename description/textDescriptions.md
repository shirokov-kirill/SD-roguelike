# Описание Component Diagram

1. Изначально пользователь запускает приложение из Main компоненты.
2. Для того, чтобы проинициализировать состояние, а также создать все необходимые объекты используется Initializer.
3. В дальнейшем Controller реализует весь жизненный цикл приложения (получение пользовательского ввода, интерпретация, изменение состояния приложения через State Modification Handler, реализация перерисовки в компоненте View через callback, дополнительные технические функции)
4. View занимается лишь отрисовкой состояния для пользователя, при этом не имеет какого-либо состояния

# Описание Class Diagram

1. Class Controller содержит в себе состояние программы на уровне администрирования (начата ли игра, достигнута ли победа, открыты ли диалоговые окна и тд)
2. ActionsQueue – это асинхронная очередь запросов от пользователя. В рамках данной игры хорошо бы понимать, что пользователь теоретически может создавать запросы быстрее, чем мы их будем обрабатывать, но  в зависимости от видимого результата этот класс может быть не добавлен
3. Class AppState является хранилищем состояния, при этом его методы являются строгим подмножеством методов из StateModificationsHandler. GameMap и AdditionalInfo имеют методы, связанные лишь только с их уровнем абстракции
4. StateModificationsHandler в данной ситуации не играет значительной роли, но полезен будет для (возможно) логирования действий, удобен для работы с несколькими состояниями (если такое потребуется), в том числе, например, для реализации Сохранений
5. Архитектура сделана таким образом, что легко можно заменить View составляющую, или Model составляющую на другие, с другой логикой, при этом при совпадении интерфейсов приложение сможет продолжать работу. Ровно для этого же эффекта из View вынесено любое состояние. Сам View не хранит никакой информации, а лишь визуализирует переданную.
