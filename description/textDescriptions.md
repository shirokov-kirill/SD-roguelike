# Описание Component Diagram

1. Изначально пользователь запускает приложение из Main компоненты.
2. Для того, чтобы проинициализировать состояние, а также создать все необходимые объекты используется Initializer.
3. В дальнейшем Controller реализует весь жизненный цикл приложения (получение пользовательского ввода, интерпретация, уведомление онеобходимости изменения состояния приложения через State Modification Handler, реализация перерисовки в компоненте View через callback, дополнительные технические функции)
4. Для изменения состояния отдельной игры используется связанный с нею движок (Engine), который включён в модель, так как непосредственно с ней связан
5. View занимается лишь отрисовкой состояния для пользователя, при этом не имеет какого-либо состояния

# Описание Main Class Diagram

1. Class Controller содержит в себе состояние программы на уровне администрирования (начата ли игра, достигнута ли победа, открыты ли диалоговые окна и тд)
2. Class AppState является хранилищем состояния, при этом его методы являются строгим подмножеством методов из StateModificationsHandler. GameMap и AdditionalInfo имеют методы, связанные лишь только с их уровнем абстракции
3. StateModificationsHandler в данной ситуации не играет значительной роли, но полезен будет для (возможно) логирования действий, удобен для работы с несколькими состояниями (если такое потребуется), в том числе, например, для реализации Сохранений
4. Viewer использует набор экранов, созданных с помощью библиотеки Zircon, применяя тот или иной в зависимости от команды пришедшей из Controller.
5. В самом начале игры запускается Initializer, который генерирует начальное состояние приложения с помощью фабрики GameWorldBuilder и передаёт его в Controller для дальнейшей работы.
6. Один из циклов работы приложения (ход пользователя) происходит путем передачи внутрь состояния необходимых данных, собираемых на всех уровнях иерархии Controller -> StateModificationHandler -> AppState -> Game.

# Описание Game Class Diagram
1. Класс Game хранит в себе поле GameWorld, а также игрока -- класс GameEntity<T>, параметризованный объектом Player
2. GameWorld хранит в себе движок. При желании обновиться, GameWorld не делает это самостоятельно, а вызывается движок, который делает всё за него. В любой игре состояние может изменяться лишь под действием сущностей, которые в ней находятся, поэтому движок для каждой сущности запускает процесс обновления состояния (вызовы behaviors, о которых далее), что в дальнейшем приводит к изменению всего состояния GameWorld, на чём итерация завершается, а обновлённая информация показывается на экране.
3. GameWorld также хранит карту, состоящую из GameBlock, определённого размера, сгенерированную в Initializer  в самом начале игры (и изменяющуюся в процессе)
4. GameEntity<BaseType> -- класс любой сущности в игре, а наследование происходит путем наследования аргументов в параметре. (схема наследования от BaseType приведена)

# Описание ABF (Attributes-Behaviors-Facets) Class Diagram
1. Attributes отвечают за характеристики существ в игре (здоровье/урон/уровень/внешность/позицию/инвентарь и тд). Они определяются для определённых типов сущностей через typealias. Например, здоровье, урон и уровень заданы для GameEntity<Creature> (живой сущности), а добавочные здоровье и урон для GameEntity<Equipment> (экипировки).
2. Behaviors отвечают за внутреннее поведение существ, где определяется необходимость или желание их совершить то или иное действие (в случае пользовательского ввода происходит интерпретация в контекст игры). Там создаются сообщения (GameMessage), которые затем передаются сущности и которые та пытается обработать.
3. Facets отвечают за внешнее поведение. Получив сообщение, конкретный Facet интерпретирует его и соответствующим образом воздействует на состояние игры (GameWorld), которое изменяется, тем самым изменяя своё отображение на экране.
